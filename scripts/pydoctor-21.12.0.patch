From 284115bf7275d86e245f5ce20cd4c1f0a97745c8 Mon Sep 17 00:00:00 2001
From: Fabio Zanini <fabio.zanini@fastmail.fm>
Date: Wed, 5 Jan 2022 17:39:23 +1100
Subject: [PATCH] update_patch

---
 pydoctor/astbuilder.py                    |  2 +-
 pydoctor/epydoc2stan.py                   |  7 +++++-
 pydoctor/model.py                         | 27 +++++++++++++++++------
 pydoctor/templatewriter/pages/__init__.py |  4 +++-
 4 files changed, 30 insertions(+), 10 deletions(-)

diff --git a/pydoctor/astbuilder.py b/pydoctor/astbuilder.py
index 831643f5..8895ebd3 100644
--- a/pydoctor/astbuilder.py
+++ b/pydoctor/astbuilder.py
@@ -221,7 +221,7 @@ class ModuleVistor(ast.NodeVisitor):
             self.newAttr = None
 
     def visit_Module(self, node: ast.Module) -> None:
-        assert self.module.docstring is None
+        #assert self.module.docstring is None
 
         self.builder.push(self.module, 0)
         if len(node.body) > 0 and isinstance(node.body[0], ast.Expr) and isinstance(node.body[0].value, ast.Str):
diff --git a/pydoctor/epydoc2stan.py b/pydoctor/epydoc2stan.py
index ed72e01d..77a76c1e 100644
--- a/pydoctor/epydoc2stan.py
+++ b/pydoctor/epydoc2stan.py
@@ -189,6 +189,11 @@ class _EpydocLinker(DocstringLinker):
             target = src.resolveName(identifier)
             if target is not None:
                 return target
+            if isinstance(src, model.Class):
+                for base in src.allbases():
+                    target = base.resolveName(identifier)
+                    if target is not None:
+                        return target
             src = src.parent
 
         # Walk up the object tree again and see if 'identifier' refers to an
@@ -592,7 +597,7 @@ class FieldHandler:
 
     def handleUnknownField(self, field: Field) -> None:
         name = field.tag
-        field.report(f"Unknown field '{name}'" )
+        #field.report(f"Unknown field '{name}'" )
         self.unknowns[name].append(FieldDesc(name=field.arg, body=field.format()))
 
     def handle(self, field: Field) -> None:
diff --git a/pydoctor/model.py b/pydoctor/model.py
index 07fa858a..82cc55c7 100644
--- a/pydoctor/model.py
+++ b/pydoctor/model.py
@@ -14,7 +14,7 @@ import platform
 import sys
 import types
 from enum import Enum
-from inspect import Signature
+from inspect import Signature, signature
 from optparse import Values
 from pathlib import Path
 from typing import (
@@ -513,7 +513,8 @@ class Function(Inheritable):
     is_async: bool
     annotations: Mapping[str, Optional[ast.expr]]
     decorators: Optional[Sequence[ast.expr]]
-    signature: Signature
+    signature: Optional[Signature]
+    text_signature: str = ""
 
     def setup(self) -> None:
         super().setup()
@@ -780,15 +781,26 @@ class System:
 
     def _introspectThing(self, thing: object, parent: Documentable, parentMod: _ModuleT) -> None:
         for k, v in thing.__dict__.items():
-            if (isinstance(v, (types.BuiltinFunctionType, types.FunctionType))
-                    # In PyPy 7.3.1, functions from extensions are not
+            # TODO(ntamas): MethodDescriptorType and ClassMethodDescriptorType are Python 3.7 only.
+            if (isinstance(v, (types.BuiltinFunctionType, types.FunctionType, types.MethodDescriptorType, types.ClassMethodDescriptorType))
                     # instances of the above abstract types.
-                    or v.__class__.__name__ == 'builtin_function_or_method'):
+                    or (hasattr(v, "__class__") and v.__class__.__name__ == 'builtin_function_or_method')):
+
+
                 f = self.Function(self, k, parent)
                 f.parentMod = parentMod
                 f.docstring = v.__doc__
                 f.decorators = None
-                f.signature = Signature()
+                try:
+                    f.signature = signature(v)
+                except Exception:
+                    f.text_signature = (getattr(v, "__text_signature__") or "") + " (INVALID)"
+                    f.signature = None
+                f.is_async = False
+                f.annotations = {
+                    name: None for name in (f.signature.parameters if f.signature else {})
+                }
+
                 self.addObject(f)
             elif isinstance(v, type):
                 c = self.Class(self, k, parent)
@@ -916,7 +928,8 @@ class System:
             mod.state = ProcessingState.PROCESSED
             head = self.processing_modules.pop()
             assert head == mod.fullName()
-        self.unprocessed_modules.remove(mod)
+        if mod in self.unprocessed_modules:
+            self.unprocessed_modules.remove(mod)
         self.progress(
             'process',
             self.module_count - len(self.unprocessed_modules),
diff --git a/pydoctor/templatewriter/pages/__init__.py b/pydoctor/templatewriter/pages/__init__.py
index d032d495..dab775cf 100644
--- a/pydoctor/templatewriter/pages/__init__.py
+++ b/pydoctor/templatewriter/pages/__init__.py
@@ -60,7 +60,9 @@ def format_signature(function: model.Function) -> "Flattenable":
     Return a stan representation of a nicely-formatted source-like function signature for the given L{Function}.
     Arguments default values are linked to the appropriate objects when possible.
     """
-    return html2stan(str(function.signature))
+    return html2stan(
+        str(function.signature) if function.signature else function.text_signature or "(...)",
+    )
 
 class DocGetter:
     """L{epydoc2stan} bridge."""
-- 
2.34.1

